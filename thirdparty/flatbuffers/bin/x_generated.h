// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_X_FLATIDL_H_
#define FLATBUFFERS_GENERATED_X_FLATIDL_H_

#include "flatbuffers/flatbuffers.h"

namespace FlatIDL {

struct Msg1;

struct Msg1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INT1 = 4,
    VT_STR1 = 6,
    VT_STR2 = 8
  };
  int32_t int1() const {
    return GetField<int32_t>(VT_INT1, 0);
  }
  const flatbuffers::String *str1() const {
    return GetPointer<const flatbuffers::String *>(VT_STR1);
  }
  const flatbuffers::String *str2() const {
    return GetPointer<const flatbuffers::String *>(VT_STR2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INT1) &&
           VerifyOffset(verifier, VT_STR1) &&
           verifier.VerifyString(str1()) &&
           VerifyOffset(verifier, VT_STR2) &&
           verifier.VerifyString(str2()) &&
           verifier.EndTable();
  }
};

struct Msg1Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_int1(int32_t int1) {
    fbb_.AddElement<int32_t>(Msg1::VT_INT1, int1, 0);
  }
  void add_str1(flatbuffers::Offset<flatbuffers::String> str1) {
    fbb_.AddOffset(Msg1::VT_STR1, str1);
  }
  void add_str2(flatbuffers::Offset<flatbuffers::String> str2) {
    fbb_.AddOffset(Msg1::VT_STR2, str2);
  }
  explicit Msg1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Msg1Builder &operator=(const Msg1Builder &);
  flatbuffers::Offset<Msg1> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Msg1>(end);
    return o;
  }
};

inline flatbuffers::Offset<Msg1> CreateMsg1(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t int1 = 0,
    flatbuffers::Offset<flatbuffers::String> str1 = 0,
    flatbuffers::Offset<flatbuffers::String> str2 = 0) {
  Msg1Builder builder_(_fbb);
  builder_.add_str2(str2);
  builder_.add_str1(str1);
  builder_.add_int1(int1);
  return builder_.Finish();
}

inline flatbuffers::Offset<Msg1> CreateMsg1Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t int1 = 0,
    const char *str1 = nullptr,
    const char *str2 = nullptr) {
  auto str1__ = str1 ? _fbb.CreateString(str1) : 0;
  auto str2__ = str2 ? _fbb.CreateString(str2) : 0;
  return FlatIDL::CreateMsg1(
      _fbb,
      int1,
      str1__,
      str2__);
}

inline const FlatIDL::Msg1 *GetMsg1(const void *buf) {
  return flatbuffers::GetRoot<FlatIDL::Msg1>(buf);
}

inline const FlatIDL::Msg1 *GetSizePrefixedMsg1(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<FlatIDL::Msg1>(buf);
}

inline bool VerifyMsg1Buffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<FlatIDL::Msg1>(nullptr);
}

inline bool VerifySizePrefixedMsg1Buffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<FlatIDL::Msg1>(nullptr);
}

inline void FinishMsg1Buffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FlatIDL::Msg1> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMsg1Buffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<FlatIDL::Msg1> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace FlatIDL

#endif  // FLATBUFFERS_GENERATED_X_FLATIDL_H_
